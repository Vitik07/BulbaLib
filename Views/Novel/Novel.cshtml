@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf
@{
    ViewData["Title"] = "Новелла";

    Layout = null;
}
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <title>@ViewData["Title"] — BulbaLib</title>
    <link rel="stylesheet" href="@Url.Content("~/css/Novel.css")" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/themes/light.css" />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/shift-away.css" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <style>
        .novel-author-link {
            color: var(--link, #369bf6);
            text-decoration: none;
            font-weight: 600;
            transition: color 0.15s;
        }

            .novel-author-link:hover {
                color: var(--accent-blue-light, #3a8bfd);
                text-decoration: underline;
            }

        /* Модалка просмотра обложек */
        .cover-modal {
            display: none;
            position: fixed;
            z-index: 10001;
            padding-top: 40px;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.87);
            text-align: center;
        }

        .cover-modal-content {
            margin: auto;
            display: block;
            max-width: 90vw;
            max-height: 85vh;
            border-radius: 12px;
            box-shadow: 0 8px 40px #000a;
        }

        .cover-modal-close {
            position: absolute;
            top: 18px;
            right: 40px;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10002;
        }

        .cover-modal-prev, .cover-modal-next {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.3);
            color: #fff;
            border: none;
            font-size: 48px;
            padding: 16px 20px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10002;
        }

        .cover-modal-prev {
            left: 60px;
        }

        .cover-modal-next {
            right: 60px;
        }
    </style>
</head>
<body>
    <input type="hidden" id="RequestVerificationToken" name="__RequestVerificationToken" value="@Xsrf.GetAndStoreTokens(Context).RequestToken" />
    <div class="novel-header-bar">
        <div class="header-logo-btn" onclick="goToMainMenu()" role="button" tabindex="0" aria-label="Перейти на главную">
            <img src="/favicon.ico" alt="logo" />
            <span class="header-logo-text">BulbaLib</span>
        </div>
    </div>
    <div class="novel-main-bg">
        <div class="novel-main-container">
            <!-- SIDEBAR -->
            <aside class="novel-sidebar" aria-label="Боковая панель новеллы">
                <div class="novel-cover-wrap">
                    <img class="novel-cover" id="novel-cover-img" src="/img/no-cover.png" alt="Обложка новеллы" style="cursor:pointer;" />
                </div>
                <!-- Модалка для обложек -->
                <div id="cover-modal" class="cover-modal">
                    <span class="cover-modal-close" id="cover-modal-close">&times;</span>
                    <img class="cover-modal-content" id="cover-modal-img">
                    <button class="cover-modal-prev" id="cover-modal-prev">&lt;</button>
                    <button class="cover-modal-next" id="cover-modal-next">&gt;</button>
                </div>
                <button class="sidebar-btn read-btn" type="button" id="read-btn">
                    <i class="fa-solid fa-book-open fa-fw"></i>
                    <span id="read-btn-text">Продолжить читать</span>
                </button>
                <div class="status-dropdown" id="status-dropdown">
                    <button class="status-select-btn status-none" type="button" id="status-btn">
                        <i class="fa-solid fa-plus"></i>
                        <span id="status-btn-text">+ добавить в планы</span>
                        <i class="fa-solid fa-caret-down"></i>
                    </button>
                    <div class="status-dropdown-list" id="status-list">
                        <button class="status-option status-reading" data-status="reading">
                            <i class="fa-solid fa-book-open"></i>Читаю
                        </button>
                        <button class="status-option status-completed" data-status="completed">
                            <i class="fa-solid fa-check"></i>Прочитано
                        </button>
                        <button class="status-option status-favorite" data-status="favorite">
                            <i class="fa-solid fa-heart"></i>Любимое
                        </button>
                        <button class="status-option status-dropped" data-status="dropped">
                            <i class="fa-solid fa-ban"></i>Брошено
                        </button>
                    </div>
                </div>
                <div class="novel-actions-under-status novel-actions-panel">
                    @if (ViewData["CanEditNovel"] != null && (bool)ViewData["CanEditNovel"])

                    {

                        // Assuming Model.Id is the novel's ID. If this view is fully client-side, this needs JS.

                        // For MVC context, @Model.Id or a similar server-passed variable is expected.

                        // The asp-route-id likely comes from the model of the page.
                        <a asp-controller="Novels" asp-action="Edit" asp-route-id="@ViewData["NovelId"]" class="novel-action-btn">
                            <i class="fa-solid fa-pen"></i> Редактировать
                        </a>
                    }
                    @if (ViewData["CanDeleteNovel"] != null && (bool)ViewData["CanDeleteNovel"])

                    {
                        <form asp-controller="Novels" asp-action="Delete" asp-route-id="@ViewData["NovelId"]" method="post" onsubmit="return confirm('Вы уверены, что хотите удалить эту новеллу? Это действие необратимо.');" style="display:inline;">
                            @Html.AntiForgeryToken()
                            <button type="submit" class="novel-action-btn novel-delete">
                                <i class="fa-solid fa-trash"></i> Удалить
                            </button>
                        </form>
                    }
                    @if (ViewData["CanAddChapter"] != null && (bool)ViewData["CanAddChapter"])

                    {

                        // Points to the new MVC action in ChaptersController
                        <a asp-controller="Chapters" asp-action="Create" asp-route-novelId="@ViewData["NovelId"]" class="novel-action-btn novel-add-chapter">
                            <i class="fa-solid fa-plus"></i> Добавить главу
                        </a>
                    }
                </div>
                <div class="novel-info-panel">
                    <div class="novel-info-row">
                        <span class="novel-info-label">Тип</span>
                        <span class="novel-info-value" id="sidebar-type">-</span>
                    </div>
                    <div class="novel-info-row">
                        <span class="novel-info-label">Формат</span>
                        <span class="novel-info-value" id="sidebar-format">-</span>
                    </div>
                    <div class="novel-info-row">
                        <span class="novel-info-label">Выпуск</span>
                        <span class="novel-info-value" id="sidebar-release">-</span>
                    </div>
                    <div class="novel-info-row">
                        <span class="novel-info-label">Глав</span>
                        <span class="novel-info-value" id="sidebar-chapters">-</span>
                    </div>
                    <div class="novel-info-row" id="novel-author-row" style="display:none;">
                        <span class="novel-info-label">Автор</span>
                        <span class="novel-info-value" id="sidebar-author">-</span>
                    </div>
                    <div class="novel-info-row" id="novel-translators-row" style="display:none;">
                        <span class="novel-info-label">Переводчик</span>
                        <span class="novel-info-value" id="sidebar-translators">-</span>
                    </div>
                </div>
            </aside>
            <main class="novel-content-block" aria-label="Основное содержимое новеллы">
                <div class="novel-tabs" style="margin-top:0;">
                    <div class="novel-tabs-header">
                        <button class="novel-tab-btn active" id="tab-description-btn" onclick="showTab('description')">Описание</button>
                        <button class="novel-tab-btn" id="tab-chapters-btn" onclick="showTab('chapters')">Главы</button>
                    </div>
                    <div class="novel-tabs-content">
                        <div class="tab-pane" id="tab-description" style="display:block;">
                            <h1 class="novel-page-title novel-title"></h1>
                            <div class="novel-alt-title text-secondary" aria-label="Альтернативное название"></div>
                            <div class="novel-description" id="novel-description"></div>
                            <div class="novel-tags-block" aria-label="Информация о жанрах и тегах">
                                <div class="genres-block">
                                    <div class="block-title">Жанры</div>
                                    <div class="novel-genres novel-tag-list"></div>
                                </div>
                                <div class="tags-block">
                                    <div class="block-title">Теги</div>
                                    <div class="novel-tags novel-tag-list"></div>
                                </div>
                            </div>
                            <div class="related-block">
                                <div class="block-title">Связанное</div>
                                <div class="related-list" id="related-list">
                                    <!-- Карточки связанного будут вставляться тут -->
                                </div>
                            </div>
                        </div>
                        <div class="tab-pane" id="tab-chapters" style="display:none;">
                            <div class="block-title" style="margin-top:0;">Список глав</div>
                            <div class="chapter-list" id="chapter-list"></div>
                        </div>
                    </div>
                </div>
                <div class="novel-main-error" style="display:none;color:#e74c3c;margin-top:2em;" role="alert">
                    Ошибка загрузки новеллы.
                </div>
            </main>
        </div>
    </div>
    <script src="https://unpkg.com/@@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.7/dist/tippy-bundle.umd.min.js"></script>
    <script>
        const baseUrl = window.location.origin;

        function getNovelIdFromUrl() {
            console.log("Entering getNovelIdFromUrl");
            const match = window.location.pathname.match(/novel\/(\d+)/);
            const result = match ? match[1] : '1';
            console.log("Exiting getNovelIdFromUrl, result:", result);
            return result;
        }
        function goToMainMenu() {
            window.location.href = baseUrl + "/";
        }

        // --- КАРТИНКИ (обложки) ---
        let covers = [];
        let currentCoverIdx = 0; // индекс текущей мини-картинки
        let modalCoverIdx = 0;   // индекс текущей картинки в модалке

        // Функция для отображения мини-картинки (и обновления текущего индекса!)
        function setSidebarCover(idx) {
            console.log("Entering setSidebarCover, idx:", idx, "covers:", covers);
            if (!covers.length) {
                document.getElementById('novel-cover-img').src = '/img/no-cover.png';
                currentCoverIdx = 0;
                console.log("setSidebarCover: No covers, using default.");
            } else {
                if (typeof idx === "undefined" || idx < 0 || idx >= covers.length) idx = covers.length - 1;
                document.getElementById('novel-cover-img').src = covers[idx];
                currentCoverIdx = idx;
                console.log("setSidebarCover: Set cover to index", currentCoverIdx, "path:", covers[currentCoverIdx]);
            }
            console.log("Exiting setSidebarCover");
        }

        // --- Модальное окно ---
        document.addEventListener('DOMContentLoaded', () => {
            // Открыть модалку с текущей мини-картинкой
            document.getElementById('novel-cover-img').onclick = function () {
                if (!covers.length) return;
                modalCoverIdx = currentCoverIdx;
                showModalCover(modalCoverIdx);
                document.getElementById('cover-modal').style.display = 'block';
            };
            // Закрыть
            document.getElementById('cover-modal-close').onclick = function () {
                document.getElementById('cover-modal').style.display = 'none';
            };
            // Цикличное листание назад
            document.getElementById('cover-modal-prev').onclick = function () {
                if (!covers.length) return;
                modalCoverIdx = (modalCoverIdx - 1 + covers.length) % covers.length;
                showModalCover(modalCoverIdx);
            };
            // Цикличное листание вперед
            document.getElementById('cover-modal-next').onclick = function () {
                if (!covers.length) return;
                modalCoverIdx = (modalCoverIdx + 1) % covers.length;
                showModalCover(modalCoverIdx);
            };
        });

        function showModalCover(idx) {
            console.log("Entering showModalCover, idx:", idx, "covers:", covers);
            if (covers && covers[idx]) {
                document.getElementById('cover-modal-img').src = covers[idx];
                console.log("showModalCover: Displaying cover index", idx, "path:", covers[idx]);
            } else {
                console.warn("showModalCover: Invalid index or covers array empty.");
            }
            console.log("Exiting showModalCover");
        }

        // --- renderNovel с поддержкой нескольких обложек ---
        function renderNovel(novelFromApi) { // Renamed to avoid confusion with global 'novel' if any
            console.log("Entering renderNovel, novelFromApi:", novelFromApi);
            covers = Array.isArray(novelFromApi.covers) ? novelFromApi.covers : [];
            setSidebarCover(covers.length - 1); // Log inside setSidebarCover

            currentCoverIdx = covers.length ? covers.length - 1 : 0;

            document.getElementById('novel-cover-img').src = covers.length ? covers[currentCoverIdx] : '/img/no-cover.png';
            document.getElementById('sidebar-type').textContent = novelFromApi.type || '-';
            document.getElementById('sidebar-format').textContent = novelFromApi.format || '-';
            document.getElementById('sidebar-release').textContent = novelFromApi.releaseYear ? novelFromApi.releaseYear + ' г.' : '-';
            document.getElementById('sidebar-chapters').textContent = (novelFromApi.chapters && novelFromApi.chapters.length) || novelFromApi.chapterCount || '-';

            // --- Автор ---
            const authorRow = document.getElementById('novel-author-row');
            const authorSpan = document.getElementById('sidebar-author');
            authorRow.style.display = '';
            if (novelFromApi.author && novelFromApi.author.id && novelFromApi.author.login) {
                authorSpan.innerHTML = `<a href="/profile/${novelFromApi.author.id}" class="novel-author-link">${novelFromApi.author.login}</a>`;
            } else {
                console.log("renderNovel: Author data is missing or incomplete.", novelFromApi.author);
                authorSpan.textContent = '-';
            }

            // --- Переводчики ---
            const translatorsRow = document.getElementById('novel-translators-row');
            const translatorsSpan = document.getElementById('sidebar-translators');
            translatorsRow.style.display = '';
            if (novelFromApi.translators && Array.isArray(novelFromApi.translators) && novelFromApi.translators.length) {
                translatorsSpan.innerHTML = novelFromApi.translators
                    .map(tr => `<a href="/profile/${tr.id}" class="novel-author-link">${tr.login}</a>`)
                    .join(', ');
            } else {
                console.log("renderNovel: Translators data is missing or empty.", novelFromApi.translators);
                translatorsSpan.textContent = '-';
            }

            // Заголовки и описание
            document.querySelector('.novel-page-title').textContent = novelFromApi.title || '';
            
            const altTitleContainer = document.querySelector('.novel-alt-title');
            altTitleContainer.innerHTML = ''; // Clear previous content

            let allAlternativeTitles = [];
            if (novelFromApi.alternativeTitles) {
                try {
                    // Try parsing as JSON array first
                    allAlternativeTitles = JSON.parse(novelFromApi.alternativeTitles);
                    if (!Array.isArray(allAlternativeTitles)) {
                        // If not an array after parsing, it might be a single string that was JSON encoded
                        // or some other JSON type. For simplicity, if it's not an array,
                        // treat the original string as a single alternative title or comma/newline separated.
                        throw new Error("Parsed JSON is not an array.");
                    }
                } catch (e) {
                    // If JSON.parse fails, or it wasn't an array, split by common delimiters (newline or comma)
                    allAlternativeTitles = novelFromApi.alternativeTitles.split(/[\n,]/)
                                              .map(title => title.trim())
                                              .filter(title => title.length > 0);
                }
            }

            if (allAlternativeTitles.length > 0) {
                const firstAltTitleSpan = document.createElement('span');
                firstAltTitleSpan.textContent = allAlternativeTitles[0];
                altTitleContainer.appendChild(firstAltTitleSpan);

                if (allAlternativeTitles.length > 1) {
                    const moreLink = document.createElement('a');
                    moreLink.href = '#';
                    moreLink.textContent = ' (подробнее...)';
                    moreLink.className = 'alt-titles-more-link';
                    altTitleContainer.appendChild(moreLink);

                    const fullAltTitlesContainer = document.createElement('div');
                    fullAltTitlesContainer.className = 'full-alt-titles-container';
                    fullAltTitlesContainer.style.display = 'none'; // Hidden by default
                    // Preserve line breaks by creating a div for each title
                    allAlternativeTitles.forEach(title => {
                        const titleDiv = document.createElement('div');
                        titleDiv.textContent = title;
                        fullAltTitlesContainer.appendChild(titleDiv);
                    });
                    altTitleContainer.appendChild(fullAltTitlesContainer);

                    moreLink.addEventListener('click', function(event) {
                        event.preventDefault();
                        const isHidden = fullAltTitlesContainer.style.display === 'none';
                        fullAltTitlesContainer.style.display = isHidden ? 'block' : 'none';
                        moreLink.textContent = isHidden ? ' (скрыть)' : ' (подробнее...)';
                        if (isHidden) {
                            firstAltTitleSpan.style.display = 'none'; // Hide the first title when showing all
                        } else {
                            firstAltTitleSpan.style.display = ''; // Show first title when hiding all
                        }
                    });
                }
            } else {
                altTitleContainer.textContent = ''; // No alternative titles
            }

            const descBlock = document.getElementById('novel-description');
            const fullDescription = novelFromApi.description || '';
            const shortDesc = fullDescription.slice(0, 400);

            if (fullDescription.length > 400) {
                descBlock.innerHTML = `
                                                        <span class="desc-short">${shortDesc}...</span>
                                                        <span class="desc-full" style="display:none;">${fullDescription}</span>
                                                        <a href="#" class="desc-more" id="desc-toggle" onclick="toggleDesc(); return false;">Подробнее...</a>
                                                    `;
            } else {
                descBlock.textContent = fullDescription;
            }

            // Жанры
            const genresBlock = document.querySelector('.novel-genres');
            let genresList = [];
            if (novelFromApi.genres) {
                try {
                    // Предполагаем, что novelFromApi.genres это всегда строка JSON-массива
                    genresList = JSON.parse(novelFromApi.genres);
                    if (!Array.isArray(genresList)) {
                        console.warn("renderNovel: novelFromApi.genres parsed but is not an array:", genresList);
                        genresList = []; // Если не массив, считаем пустым
                    }
                } catch (e) {
                    console.error("renderNovel: Error parsing novelFromApi.genres JSON:", e, "Input:", novelFromApi.genres);
                    genresList = []; // В случае ошибки парсинга, считаем пустым
                }
            }
            console.log("renderNovel: Parsed genresList:", genresList);
            genresBlock.innerHTML = genresList
                .map(g => `<span class="novel-tag genre">${String(g).trim()}</span>`) // Убедимся что g это строка и тримим
                .join('');

            // Теги
            const tagsBlock = document.querySelector('.novel-tags');
            let tagsList = [];
            if (novelFromApi.tags) {
                try {
                    // Предполагаем, что novelFromApi.tags это всегда строка JSON-массива
                    tagsList = JSON.parse(novelFromApi.tags);
                    if (!Array.isArray(tagsList)) {
                        console.warn("renderNovel: novelFromApi.tags parsed but is not an array:", tagsList);
                        tagsList = []; // Если не массив, считаем пустым
                    }
                } catch (e) {
                    console.error("renderNovel: Error parsing novelFromApi.tags JSON:", e, "Input:", novelFromApi.tags);
                    tagsList = []; // В случае ошибки парсинга, считаем пустым
                }
            }
            console.log("renderNovel: Parsed tagsList:", tagsList);
            tagsBlock.innerHTML = tagsList
                .map(t => `<span class="novel-tag tag">${String(t).trim()}</span>`) // Убираем #, убедимся что t это строка и тримим
                .join('');

            renderChaptersWithBookmark(chapterViewModels); // Log inside renderChaptersWithBookmark

            // --- вкладка связанное ---
            // The parsing of relatedNovelIds is now handled within renderRelatedNovels
            renderRelatedNovels(novelFromApi.relatedNovelIds);

            // --- Обработка кнопки "Читать" с учетом закладки ---
            const readBtnText = document.getElementById('read-btn-text');
            const readBtn = document.getElementById('read-btn');
            let chapterIdToRead = "";

            if (novelFromApi.bookmarkChapterId && novelFromApi.bookmarkChapterId > 0) {
                readBtnText.textContent = 'Продолжить читать';
                chapterIdToRead = novelFromApi.bookmarkChapterId;
            } else if (novelFromApi.chapters && novelFromApi.chapters.length) {
                readBtnText.textContent = 'Начать читать';
                chapterIdToRead = novelFromApi.chapters[0].id;
            } else {
                readBtnText.textContent = 'Начать читать';
            }
            readBtn.dataset.chapterId = chapterIdToRead;
            console.log("Exiting renderNovel");
        }

        function toggleDesc() {
            console.log("Entering toggleDesc");
            var shortDesc = document.querySelector('.desc-short');
            var fullDesc = document.querySelector('.desc-full');
            var toggle = document.getElementById('desc-toggle');
            if (shortDesc.style.display !== 'none') {
                shortDesc.style.display = 'none';
                fullDesc.style.display = '';
                toggle.textContent = "Свернуть";
                console.log("toggleDesc: Switched to full description");
            } else {
                shortDesc.style.display = '';
                fullDesc.style.display = 'none';
                toggle.textContent = "Подробнее...";
                console.log("toggleDesc: Switched to short description");
            }
            console.log("Exiting toggleDesc");
        }

        function showTab(tab) {
            console.log("Entering showTab, tab:", tab);
            document.getElementById('tab-description').style.display = (tab === 'description') ? 'block' : 'none';
            document.getElementById('tab-chapters').style.display = (tab === 'chapters') ? 'block' : 'none';
            document.getElementById('tab-description-btn').classList.toggle('active', tab === 'description');
            document.getElementById('tab-chapters-btn').classList.toggle('active', tab === 'chapters');
            console.log("Exiting showTab");
        }

        function renderChaptersWithBookmark(viewModels) {
            console.log("Entering renderChaptersWithBookmark, viewModels:", viewModels);
            const list = document.getElementById('chapter-list');
            list.innerHTML = '';

            if (!viewModels || !viewModels.length) {
                console.log("renderChaptersWithBookmark: No chapters to render.");
                list.innerHTML = '<div style="color:#888;">Главы отсутствуют</div>';
                console.log("Exiting renderChaptersWithBookmark (no chapters)");
                return;
            }

            // Helper function to parse chapter number string
            function parseChapterNumber(numberStr) {
                if (!numberStr) return { volume: null, chapterNum: [], isNumeric: false, original: "" };
                numberStr = String(numberStr).trim();
                let volume = null;
                let chapterPart = numberStr;

                const tomMatch = numberStr.match(/Том\s*(\d+)/i);
                if (tomMatch) {
                    volume = parseInt(tomMatch[1], 10);
                    chapterPart = numberStr.substring(tomMatch[0].length).trim();
                }

                const glavaMatch = chapterPart.match(/(?:Глава\s*)?([\d\.\-\w]+)/i);
                let chapterNumParts = [];
                let isNumeric = true;
                let originalChapterStr = "";

                if (glavaMatch && glavaMatch[1]) {
                    originalChapterStr = glavaMatch[1];
                    chapterNumParts = originalChapterStr.split('.').map(part => {
                        const num = parseFloat(part);
                        if (isNaN(num)) isNumeric = false;
                        return isNaN(num) ? part : num; // Keep non-numeric parts as strings for lexicographical comparison if needed
                    });
                } else {
                     // If no "Глава" or number, treat the whole remaining part as non-numeric chapter identifier
                    chapterNumParts = [chapterPart];
                    isNumeric = false;
                    originalChapterStr = chapterPart;
                }
                 if (chapterNumParts.length === 0 && chapterPart.trim() !== "") { // Handle cases like "Пролог" where no number is extracted
                    chapterNumParts = [chapterPart.trim()];
                    isNumeric = false;
                    originalChapterStr = chapterPart.trim();
                }


                return { volume, chapterNum: chapterNumParts, isNumeric, original: originalChapterStr };
            }

            viewModels.sort((a, b) => {
                const chapterAInfo = parseChapterNumber(a.Chapter.Number);
                const chapterBInfo = parseChapterNumber(b.Chapter.Number);

                // Sort by volume first (null volumes/no volume go last)
                if (chapterAInfo.volume !== null && chapterBInfo.volume === null) return -1;
                if (chapterAInfo.volume === null && chapterBInfo.volume !== null) return 1;
                if (chapterAInfo.volume !== null && chapterBInfo.volume !== null) {
                    if (chapterAInfo.volume < chapterBInfo.volume) return -1;
                    if (chapterAInfo.volume > chapterBInfo.volume) return 1;
                }

                // If volumes are same (or both null), sort by chapter number parts
                const len = Math.min(chapterAInfo.chapterNum.length, chapterBInfo.chapterNum.length);
                for (let i = 0; i < len; i++) {
                    const partA = chapterAInfo.chapterNum[i];
                    const partB = chapterBInfo.chapterNum[i];

                    const isPartANumeric = typeof partA === 'number';
                    const isPartBNumeric = typeof partB === 'number';

                    if (isPartANumeric && !isPartBNumeric) return -1; // Numeric parts come before non-numeric (e.g., "10" vs "10-extra")
                    if (!isPartANumeric && isPartBNumeric) return 1;

                    if (isPartANumeric && isPartBNumeric) {
                        if (partA < partB) return -1;
                        if (partA > partB) return 1;
                    } else { // Both non-numeric or mixed, compare as strings
                        const comparison = String(partA).localeCompare(String(partB), undefined, { numeric: true, sensitivity: 'base' });
                        if (comparison !== 0) return comparison;
                    }
                }

                // If one chapter number is a prefix of another (e.g., "10" vs "10.1")
                if (chapterAInfo.chapterNum.length < chapterBInfo.chapterNum.length) return -1;
                if (chapterAInfo.chapterNum.length > chapterBInfo.chapterNum.length) return 1;

                // Fallback to original string comparison if all parts are equal (should be rare)
                // or if one is purely numeric and other is not fully captured (e.g. "Глава" vs "Глава 1")
                if (chapterAInfo.isNumeric && !chapterBInfo.isNumeric && chapterBInfo.original.toLowerCase().startsWith(chapterAInfo.original.toLowerCase())) return -1;
                if (!chapterAInfo.isNumeric && chapterBInfo.isNumeric && chapterAInfo.original.toLowerCase().startsWith(chapterBInfo.original.toLowerCase())) return 1;


                return String(a.Chapter.Number).localeCompare(String(b.Chapter.Number), undefined, { numeric: true, sensitivity: 'base' });
            });


            for (const cvm of viewModels) {
                console.log(cvm);
                const chapter = cvm.Chapter;
                // Создаем контейнер для карточки главы
                const el = document.createElement('div');
                el.className = 'chapter-card';

                // Создаем ссылку для основной информации о главе
                const link = document.createElement('a');
                link.href = `/chapter/${chapter.Id}`;
                link.className = 'chapter-link'; // Новый класс для стилизации ссылки

                // Формируем текст главы (номер и название)
                let chapterDisplayText = "";
                // Используем chapter.number (который должен быть ChapterNumber из C# модели)
                // и chapter.Title (который должен быть Title из C# модели)
                if (chapter.number && chapter.number.trim() !== "") {
                    chapterDisplayText = `${chapter.number} - ${chapter.Title || chapter.title || 'Без названия'}`;
                } else {
                    chapterDisplayText = `${chapter.Title || chapter.title || 'Без названия'}`;
                }
                
                // HTML для информации внутри ссылки
                link.innerHTML = `
                    <div class="chapter-info">
                        <span class="chapter-display-text">${chapterDisplayText}</span>
                        ${chapter.date ? `<span class="chapter-item-date">${formatChapterDate(chapter.date)}</span>` : ''}
                    </div>
                `;

                // Создаем div для кнопок действий
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'chapter-item-actions';

                let actionsHtml = '';
                if (cvm.CanEdit) {
                    // Points to the new MVC action in ChaptersController
                    actionsHtml += `<a href="/Chapters/Edit/${chapter.Id}" class="chapter-action-icon-btn" data-tippy-content="Редактировать главу (MVC)"><i class="fa-solid fa-pen"></i></a>`;
                }
                if (cvm.CanDelete) {
                    const requestVerificationToken = document.getElementById('RequestVerificationToken').value;
                    // Points to the new MVC action in ChaptersController
                    actionsHtml += `<form action="/Chapters/Delete/${chapter.Id}" method="post" style="display:inline;" onsubmit="return confirm('Вы уверены, что хотите удалить эту главу?');">
                                            <input type="hidden" name="__RequestVerificationToken" value="${requestVerificationToken}" />
                                            <button type="submit" class="chapter-action-icon-btn delete" data-tippy-content="Удалить главу (MVC)"><i class="fa-solid fa-trash"></i></button>
                                        </form>`;
                }

                let isBookmarked = false;
                // Assuming 'loadedNovel.bookmarks' is an array of chapter IDs that are bookmarked by the current user for this novel.
                // This part needs to align with how bookmarks are actually fetched and stored on the client side for the novel.
                // For now, let's assume `cvm.IsBookmarked` comes from the server in ChapterViewModel or we have a similar client-side check.
                // If `ViewData["ChapterViewModels"]` is the source, `cvm.IsBookmarked` should be populated there.
                // For demonstration, I'll use `cvm.IsBookmarked` if available, otherwise fallback to a placeholder check.
                // isBookmarked = cvm.IsBookmarked || (loadedNovel && loadedNovel.bookmarks && loadedNovel.bookmarks.includes(chapter.Id));
                // const bookmarkIconHtml = isBookmarked ? '<span class="chapter-bookmark-icon bookmarked"><i class="fas fa-bookmark"></i></span>' : '<span class="chapter-bookmark-icon"><i class="far fa-bookmark"></i></span>';
                
                let bookmarkIconHtml = ''; // По умолчанию нет иконки
                // Используем cvm.IsBookmarked, которое должно быть установлено сервером при загрузке ViewData["ChapterViewModels"]
                if (cvm.IsBookmarked) { 
                    bookmarkIconHtml = '<span class="chapter-bookmark-icon bookmarked"><i class="fas fa-bookmark"></i></span>'; // Заполненная иконка (красный цвет будет через CSS)
                }

                actionsDiv.innerHTML = bookmarkIconHtml + actionsHtml;
                
                // Добавляем ссылку и кнопки в карточку главы
                el.appendChild(link);
                el.appendChild(actionsDiv);

                list.appendChild(el);
            }
            // Re-initialize Tippy for any new action buttons
            tippy('.chapter-action-icon-btn[data-tippy-content]', {
                animation: 'shift-away',
                theme: 'light',
                arrow: true,
                delay: [100, 100],
            });
            console.log("Exiting renderChaptersWithBookmark");
        }

        function formatChapterDate(unix) {
            console.log("Entering formatChapterDate, unix:", unix);
            if (!unix) {
                console.log("formatChapterDate: No unix timestamp, returning empty string.");
                console.log("Exiting formatChapterDate (no timestamp)");
                return '';
            }
            const d = new Date(unix * 1000);
            const formattedDate = d.toLocaleDateString('ru-RU');
            console.log("formatChapterDate: Formatted date:", formattedDate);
            console.log("Exiting formatChapterDate");
            return formattedDate;
        }

        async function renderRelatedNovels(relatedNovelIdsString) { // Assuming input is a string "1,2,3" or JSON array string "\[1,2,3]"
            console.log("Entering renderRelatedNovels, relatedNovelIdsString:", relatedNovelIdsString);
            const relatedList = document.getElementById('related-list');
            relatedList.innerHTML = '';
            let idsArray = [];

            if (relatedNovelIdsString) {
                try {
                    // Попытка распарсить как JSON массив
                    const parsed = JSON.parse(relatedNovelIdsString);
                    if (Array.isArray(parsed)) {
                        idsArray = parsed.map(id => parseInt(id, 10)).filter(id => !isNaN(id) && id > 0);
                    } else {
                        // Если это не массив, но JSON (например, просто число как строка "1"), попробуем как CSV
                        // Либо, если parsed это число, то idsArray = [parsed]
                        if (!isNaN(parseInt(parsed,10))) { // if it's a single number string like "1"
                             idsArray = [parseInt(parsed,10)].filter(id => !isNaN(id) && id > 0);
                        } else {
                             console.warn("RelatedNovelIds JSON parsed but is not an array or a single number string:", parsed);
                        }
                    }
                } catch (e) {
                    // Если не JSON, попробовать как CSV
                    idsArray = relatedNovelIdsString.split(',')
                        .map(idStr => parseInt(idStr.trim(), 10))
                        .filter(id => !isNaN(id) && id > 0);
                }
            }
            console.log("renderRelatedNovels: Parsed idsArray:", idsArray);

            if (!idsArray || !idsArray.length) {
                relatedList.innerHTML = '<div style="color:#888;">Нет связанных новелл</div>';
                console.log("renderRelatedNovels: No valid IDs found.");
                console.log("Exiting renderRelatedNovels (no valid IDs)");
                return;
            }

            try {
                const idString = idsArray.join(',');
                const requestUrl = `${baseUrl}/api/Novels/detailsByIds?ids=${idString}`;
                console.log("renderRelatedNovels: Fetching related novels from URL:", requestUrl);
                const response = await fetch(requestUrl);
                if (!response.ok) {
                    // Если API возвращает ошибку (например, 404, если ни один ID не найден, или 500)
                    console.error(`renderRelatedNovels: Failed to fetch related novels, status: ${response.status}, URL: ${requestUrl}`);
                    throw new Error(`Failed to fetch related novels, status: ${response.status}`);
                }
                const novels = await response.json();
                console.log("renderRelatedNovels: Received novels from API:", novels);

                if (!novels || !novels.length) {
                    relatedList.innerHTML = '<div style="color:#888;">Связанные новеллы не найдены.</div>';
                    console.log("renderRelatedNovels: No novels found from API.");
                    console.log("Exiting renderRelatedNovels (no novels from API)");
                    return;
                }

                for (const novel of novels) {
                    if (!novel) continue; // На случай, если в массиве есть null элементы
                    const card = document.createElement('div');
                    card.className = 'related-card';
                    // Используем novel.firstCoverUrl которое должно приходить от API /api/Novels/detailsByIds
                    const coverUrl = novel.firstCoverUrl || '/img/no-cover.png'; // Стандартная заглушка
                    card.innerHTML = `
                        <a href="/novel/${novel.id}" style="text-decoration:none;">
                            <img class="related-cover" src="${coverUrl.startsWith('http') || coverUrl.startsWith('/') ? coverUrl : '/' + coverUrl}" alt="Обложка ${novel.title || ''}">
                            <div class="related-title">${novel.title ? novel.title : 'Название не найдено'}</div>
                            <div class="related-type">${novel.type || ''}</div>
                        </a>
                    `;
                    relatedList.appendChild(card);
                }
                if (!relatedList.children.length) { // Дополнительная проверка, если все novel были null
                    relatedList.innerHTML = '<div style="color:#888;">Нет связанных новелл для отображения.</div>';
                }
            } catch (error) {
                console.error("Error rendering related novels:", error);
                relatedList.innerHTML = '<div style="color:red;">Ошибка загрузки связанных новелл.</div>';
            }
            console.log("Exiting renderRelatedNovels");
        }

        // === МАППИНГ СТАТУСОВ ===
        const FRONT_TO_DB_STATUS = {
            reading: "reading",
            completed: "read",
            favorite: "favorites",
            dropped: "abandoned"
        };
        const DB_TO_FRONT_STATUS = {
            reading: "reading",
            read: "completed",
            favorites: "favorite",
            abandoned: "dropped"
        };

        let loadedNovel = null;

        async function loadNovelData(novelId) {
            console.log("Entering loadNovelData, novelId:", novelId);
            try {
                const url = `${baseUrl}/api/novels/${novelId}`;
                console.log("loadNovelData: Fetching novel data from URL:", url);
                const res = await fetch(url);
                if (!res.ok) {
                    console.error("loadNovelData: Error fetching novel data, status:", res.status, "URL:", url);
                    throw new Error('Ошибка загрузки');
                }
                const novel = await res.json();
                console.log("loadNovelData: Received novel data:", novel);
                loadedNovel = novel;
                renderNovel(novel); // Log inside renderNovel
            } catch (error) {
                document.querySelector('.novel-main-error').style.display = '';
                console.error("loadNovelData: Exception during fetch or render:", error);
            }
            console.log("Exiting loadNovelData");
        }

        async function loadNovelStatus(novelId) {
            console.log("Entering loadNovelStatus, novelId:", novelId);
            try {
                const res = await fetch(`/api/users/status?novelId=${novelId}`);
                if (res.ok) {
                    const data = await res.json();
                    const frontStatus = DB_TO_FRONT_STATUS[data.status] || "none";
                    console.log("loadNovelStatus: Received status:", data.status, "Mapped to frontStatus:", frontStatus);
                    console.log("Exiting loadNovelStatus (success)");
                    return frontStatus;
                } else {
                    console.warn("loadNovelStatus: Failed to load status, response not OK:", res.status);
                }
            } catch (error) {
                console.error("loadNovelStatus: Exception during fetch:", error);
            }
            console.log("Exiting loadNovelStatus (failure or error)");
            return "none";
        }

        async function setNovelStatus(novelId, frontStatus) {
            console.log("Entering setNovelStatus, novelId:", novelId, "frontStatus:", frontStatus);
            const dbStatus = FRONT_TO_DB_STATUS[frontStatus];
            if (!dbStatus) {
                alert("Некорректный статус!");
                console.warn("setNovelStatus: Invalid frontStatus:", frontStatus);
                console.log("Exiting setNovelStatus (invalid status)");
                return null;
            }
            console.log("setNovelStatus: Mapped frontStatus to dbStatus:", dbStatus);
            try {
                const res = await fetch(`/api/users/status`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ novelId, status: dbStatus })
                });
                if (res.ok) {
                    console.log("setNovelStatus: Successfully set status. Returning frontStatus:", frontStatus);
                    console.log("Exiting setNovelStatus (success)");
                    return frontStatus;
                } else {
                    console.error("setNovelStatus: Failed to set status, response not OK:", res.status);
                }
            } catch (error) {
                console.error("setNovelStatus: Exception during fetch:", error);
            }
            console.log("Exiting setNovelStatus (failure or error)");
            return null;
        }

        // --- DOMContentLoaded основной (статусы, кнопки, тултипы и т.д.) ---
        let chapterViewModels = [];
        document.addEventListener('DOMContentLoaded', async function () {
            console.log("DOMContentLoaded: Event triggered.");
            @if (ViewData["ChapterViewModels"] != null)
            {
                <text>
                    chapterViewModels = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(ViewData["ChapterViewModels"]));
                    console.log("DOMContentLoaded: chapterViewModels loaded from ViewData:", chapterViewModels);
                </text>
            }
            else {
                <text>
                    console.log("DOMContentLoaded: No chapterViewModels found in ViewData.");
                </text>
            }

            const novelId = getNovelIdFromUrl(); // Log inside function
            console.log("DOMContentLoaded: novelId from URL:", novelId);
            await loadNovelData(novelId); // Log inside function

            // --- Статусы ---
            const statusDropdown = document.getElementById('status-dropdown');
            const statusBtn = document.getElementById('status-btn');
            const statusList = document.getElementById('status-list');
            let currentStatus = 'none';

            const STATUS_MAP = {
                none: { text: 'Добавить в планы', icon: 'fa-plus', class: 'status-none' },
                planned: { text: 'Добавить в планы', icon: 'fa-plus', class: 'status-planned' },
                reading: { text: 'Читаю', icon: 'fa-book-open', class: 'status-reading' },
                completed: { text: 'Прочитано', icon: 'fa-check', class: 'status-completed' },
                favorite: { text: 'Любимое', icon: 'fa-heart', class: 'status-favorite' },
                dropped: { text: 'Брошено', icon: 'fa-ban', class: 'status-dropped' }
            };

            function updateStatus(status) {
                const s = STATUS_MAP[status] || STATUS_MAP['none'];
                statusBtn.className = `status-select-btn ${s.class}`;
                statusBtn.innerHTML = `<i class="fa-solid ${s.icon}"></i>
                                                <span id="status-btn-text">${s.text}</span>
                                                <i class="fa-solid fa-caret-down"></i>`;
                currentStatus = status;
            }

            loadNovelStatus(novelId).then(status => {
                updateStatus(status);
            });

            statusBtn.onclick = (e) => {
                console.log("statusBtn.onclick: Clicked. Current novelId:", novelId);
                e.stopPropagation();
                fetch('/api/users/me').then(r => {
                    if (r.ok) {
                        console.log("statusBtn.onclick: User authenticated, toggling dropdown.");
                        statusDropdown.classList.toggle('open');
                    } else {
                        console.warn("statusBtn.onclick: User not authenticated, redirecting to login.");
                        alert("Вы не авторизованы!\nПожалуйста, войдите в аккаунт.");
                        window.location.href = "/login";
                    }
                });
            };

            statusList.querySelectorAll('.status-option').forEach(btn => {
                btn.onclick = function () {
                    const statusToSet = this.dataset.status;
                    console.log("status-option.onclick: Clicked. Status to set:", statusToSet, "NovelId:", novelId);
                    fetch('/api/users/me').then(r => {
                        if (!r.ok) {
                            console.warn("status-option.onclick: User not authenticated, redirecting to login.");
                            alert("Вы не авторизованы!\nПожалуйста, войдите в аккаунт.");
                            window.location.href = "/login";
                            return;
                        }
                        console.log("status-option.onclick: User authenticated. Setting novel status.");
                        setNovelStatus(novelId, statusToSet) // Log inside setNovelStatus
                            .then(srvStatus => {
                                if (srvStatus) {
                                    updateStatus(srvStatus);
                                    console.log("status-option.onclick: Status updated successfully to:", srvStatus);
                                } else {
                                    alert("Ошибка смены статуса");
                                    console.error("status-option.onclick: Failed to update status.");
                                }
                            });
                        statusDropdown.classList.remove('open');
                    });
                };
            });
            document.body.addEventListener('click', () => statusDropdown.classList.remove('open'));
            statusDropdown.addEventListener('click', e => e.stopPropagation());

            // Кнопка чтения
            const readBtn = document.getElementById('read-btn');
            readBtn.onclick = function () {
                console.log("readBtn.onclick: Clicked. loadedNovel:", loadedNovel);
                if (!loadedNovel || !loadedNovel.chapters || !loadedNovel.chapters.length) {
                    alert("Нет доступных глав для чтения.");
                    console.warn("readBtn.onclick: No chapters available to read.");
                    return;
                }
                let chapterIdToRead = ""; // Renamed from chapterId to avoid conflict
                if (loadedNovel.bookmarkChapterId && loadedNovel.bookmarkChapterId > 0) {
                    chapterIdToRead = loadedNovel.bookmarkChapterId;
                    console.log("readBtn.onclick: Continuing from bookmark, chapterIdToRead:", chapterIdToRead);
                } else {
                    chapterIdToRead = loadedNovel.chapters[0].id;
                    console.log("readBtn.onclick: Starting from first chapter, chapterIdToRead:", chapterIdToRead);
                }
                window.location.href = `/chapter/${chapterIdToRead}`;
            };

            tippy('[data-tippy-content]', {
                animation: 'shift-away',
                theme: 'light',
                arrow: true,
                delay: [100, 100],
            });
        });
    </script>
</body>
</html>