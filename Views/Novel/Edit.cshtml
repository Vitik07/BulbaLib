@model BulbaLib.Models.NovelEditModel
@{
    Layout = null;

    ViewData["Title"] = "Редактировать новеллу";

    var genresToSerialize = (ViewData["AllGenres"] as List<string>) ?? new List<string>();

    var tagsToSerialize = (ViewData["AllTags"] as List<string>) ?? new List<string>();
}
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@ViewData["Title"] - BulbaLib</title>
    <link rel="stylesheet" href="~/css/novel_form.css" asp-append-version="true" />
    <script src="~/lib/jquery/dist/jquery.min.js"></script>
    <script src="~/lib/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</head>
<body>
    <div class="container">
        <main role="main" class="pb-3">
            <h2>@ViewData["Title"]: @Model.Title</h2>
            <form asp-controller="Novels" asp-action="Edit" asp-route-id="@Model.Id" method="post" enctype="multipart/form-data" id="novelEditForm">
                @Html.AntiForgeryToken()
                <input type="hidden" asp-for="Id" />
                <div asp-validation-summary="ModelOnly" class="text-danger"></div>

                <div class="form-group mb-3">
                    <label asp-for="Title" class="control-label">Название новеллы</label>
                    <input asp-for="Title" class="form-control" />
                    <span asp-validation-for="Title" class="text-danger"></span>
                </div>

                <div class="form-group mb-3">
                    <label asp-for="Description" class="control-label">Описание</label>
                    <textarea asp-for="Description" class="form-control" rows="5"></textarea>
                    <span asp-validation-for="Description" class="text-danger"></span>
                </div>

                <!-- Author selection -->
                <div class="form-group mb-3" style="position:relative;">
                    <label asp-for="AuthorId" class="control-label">Автор</label>
                    <input type="text" id="authorNameInput" name="authorName" class="form-control" placeholder="Начните вводить имя автора..." autocomplete="off" value="@Model.AuthorLogin" />
                    <input type="hidden" asp-for="AuthorId" id="AuthorId" />
                    <span asp-validation-for="AuthorId" class="text-danger"></span>
                    <div id="authorSuggestionsContainer"></div>
                </div>

                <div class="form-group mb-3">
                    <label asp-for="NewCovers" class="control-label">Добавить новые обложки</label>
                    <input asp-for="NewCovers" type="file" multiple class="form-control" id="NewCovers" />
                    <span asp-validation-for="NewCovers" class="text-danger"></span>
                    <small class="form-text text-muted">Выберите один или несколько файлов. Новые обложки будут добавлены к существующим. Вы можете удалить отдельные текущие обложки с помощью кнопки (×).</small>
                </div>

                <div class="form-group mb-3">
                    <label class="control-label">Текущие обложки</label>
                    <div id="currentCoversContainer" class="mt-2 d-flex flex-wrap" style="display: flex; flex-wrap: wrap; flex-direction: row;">
                        @if (Model.ExistingCoverPaths != null && Model.ExistingCoverPaths.Any())

                        {

                            for (int i = 0; i < Model.ExistingCoverPaths.Count; i++)

                            {

                                var coverPath = Model.ExistingCoverPaths[i];
                                <div class="current-cover-item me-2 mb-2" style="position: relative; border: 1px solid #ddd; padding: 5px; width: 112px; height: 162px;">
                                    <img src="@Url.Content(coverPath)" alt="Обложка" style="width: 100px; height: 150px; display: block; object-fit: cover;" />
                                    <button type="button" class="btn btn-danger btn-sm remove-cover-btn" data-cover-path="@coverPath" style="position: absolute; top: 0px; right: 0px; padding: 1px 4px; line-height: 1;">&times;</button>
                                    <input type="hidden" name="ExistingCoverPaths[@i]" value="@coverPath" class="kept-cover-input" />
                                </div>
                            }

                        }

                        else

                        {
                            <p>Нет загруженных обложек.</p>
                        }
                    </div>
                    <span asp-validation-for="ExistingCoverPaths" class="text-danger"></span>
                </div>

                <div class="form-group mb-3">
                    <label asp-for="Genres" class="control-label"></label>
                    <div id="selectedGenresContainer" class="mt-2"></div>
                    <button type="button" id="addGenreBtn" class="btn btn-sm btn-primary mt-1">Добавить жанр</button>
                    <input type="hidden" asp-for="Genres" id="Genres" />
                    <span asp-validation-for="Genres" class="text-danger"></span>
                </div>

                <div class="form-group mb-3">
                    <label asp-for="Tags" class="control-label"></label>
                    <div id="selectedTagsContainer" class="mt-2"></div>
                    <button type="button" id="addTagBtn" class="btn btn-sm btn-primary mt-1">Добавить тег</button>
                    <input type="hidden" asp-for="Tags" id="Tags" />
                    <span asp-validation-for="Tags" class="text-danger"></span>
                </div>

                <div class="form-group mb-3">
                    <label asp-for="Type" class="control-label"></label>
                    <select asp-for="Type" class="form-control">
                        <option value="">-- Выберите тип --</option>
                        <option value="Япония">Япония</option>
                        <option value="Корея">Корея</option>
                        <option value="Китай">Китай</option>
                        <option value="Английский">Английский</option>
                        <option value="Авторский">Авторский</option>
                        <option value="Фанфик">Фанфик</option>
                    </select>
                    <span asp-validation-for="Type" class="text-danger"></span>
                </div>

                <div class="form-group mb-3">
                    <label asp-for="Format" class="control-label"></label>
                    <select asp-for="Format" class="form-control">
                        <option value="">-- Выберите формат --</option>
                        <option value="Веб">Веб</option>
                        <option value="Лайт">Лайт</option>
                    </select>
                    <span asp-validation-for="Format" class="text-danger"></span>
                </div>

                <div class="form-group mb-3">
                    <label asp-for="ReleaseYear" class="control-label">Год релиза</label>
                    <input asp-for="ReleaseYear" type="number" class="form-control" />
                    <span asp-validation-for="ReleaseYear" class="text-danger"></span>
                    <small class="form-text text-muted">Укажите год релиза (4 цифры, например, 2023). Год должен быть не ранее 1900 и не позднее 2099.</small>
                </div>

                @* Блок для TranslatorId удален согласно задаче *@

                <div class="form-group mb-3">
                    <label for="relatedNovelSearchInput" class="control-label">Связанные новеллы (поиск по названию)</label>
                    <input type="text" id="relatedNovelSearchInput" class="form-control" autocomplete="off" placeholder="Начните вводить название новеллы..." />
                    <div id="relatedNovelSuggestionsContainer" class="author-suggestions-container" style="display: none; max-height: 200px; overflow-y: auto; position:relative;">
                    </div>
                </div>

                <div class="form-group mb-3">
                    <label class="control-label">Выбранные связанные новеллы</label>
                    <div id="selectedRelatedNovelsContainer" class="mt-1 selected-items-container">
                    </div>
                </div>

                <div class="form-group mb-3">
                    <label asp-for="AlternativeTitles" class="control-label">Альтернативные названия</label>
                    <textarea asp-for="AlternativeTitles" class="form-control" rows="3"></textarea>
                    <span asp-validation-for="AlternativeTitles" class="text-danger"></span>
                    <small class="form-text text-muted">Каждое альтернативное название вводите с новой строки.</small>
                </div>

                <input type="hidden" asp-for="RelatedNovelIds" id="RelatedNovelIds" />

                <div class="form-group mt-3">
                    <button type="submit" class="btn btn-primary">Сохранить изменения</button>
                    <a asp-controller="NovelView" asp-action="Details" asp-route-id="@Model.Id" class="btn btn-secondary">Отмена</a>
                </div>
            </form>
        </main>
    </div>

    <div id="genreModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="closeGenreModal">&times;</span>
            <h4>Выберите или добавьте жанры</h4>
            <div id="genreListContainer"></div>
            <input type="text" id="customGenreInput" placeholder="Добавить свой жанр" class="form-control mb-2" />
            <button type="button" id="addCustomGenreBtn" class="btn btn-sm btn-secondary">Добавить свой</button>
            <button type="button" id="saveGenreSelectionBtn" class="btn btn-sm btn-success float-end">Сохранить выбор</button>
        </div>
    </div>
    <div id="tagModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="closeTagModal">&times;</span>
            <h4>Выберите или добавьте теги</h4>
            <div id="tagListContainer"></div>
            <input type="text" id="customTagInput" placeholder="Добавить свой тег" class="form-control mb-2" />
            <button type="button" id="addCustomTagBtn" class="btn btn-sm btn-secondary">Добавить свой</button>
            <button type="button" id="saveTagSelectionBtn" class="btn btn-sm btn-success float-end">Сохранить выбор</button>
        </div>
    </div>

    @await Html.PartialAsync("_ValidationScriptsPartial")

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            console.log("DOMContentLoaded: Start");

            function decodeHtmlEntities(text) {
                if (text === null || typeof text === 'undefined') {
                    return '';
                }
                var textArea = document.createElement('textarea');
                textArea.innerHTML = text;
                return textArea.value;
            }

            const allGenres = @Html.Raw(Json.Serialize(genresToSerialize));
            console.log("DOMContentLoaded: allGenres from server:", allGenres);
            const allTags = @Html.Raw(Json.Serialize(tagsToSerialize));
            console.log("DOMContentLoaded: allTags from server:", allTags);
            let selectedGenres = [];
            let selectedTags = [];
            const hiddenGenresInput = document.getElementById('Genres');
            const hiddenTagsInput = document.getElementById('Tags');

            function parseInitialItems(initialString) {
                console.log("parseInitialItems: Entering with initialString:", initialString);
                if (!initialString) {
                    console.log("parseInitialItems: initialString is empty, returning [].");
                    return [];
                }
                const decodedString = decodeHtmlEntities(initialString);
                let result = [];
                try {
                    const jsonParsed = JSON.parse(decodedString);
                    if (Array.isArray(jsonParsed)) {
                        result = jsonParsed.map(item => decodeHtmlEntities(item.toString()));
                    } else {
                         // If not an array, try splitting by comma (for legacy single string format)
                        result = decodedString.split(',')
                            .map(item => item.trim())
                            .filter(item => item)
                            .map(item => decodeHtmlEntities(item));
                    }
                } catch (e) {
                     // If JSON parsing fails, assume comma-separated string
                    console.warn("parseInitialItems: JSON.parse failed, falling back to comma-separated parsing. Error:", e);
                    result = decodedString.split(',')
                        .map(item => item.trim())
                        .filter(item => item)
                        .map(item => decodeHtmlEntities(item));
                }
                console.log("parseInitialItems: Exiting, parsed result:", result);
                return result;
            }
            selectedGenres = parseInitialItems(@Html.Raw(Json.Serialize(Model.Genres)));
            console.log("DOMContentLoaded: selectedGenres after parsing Model.Genres:", selectedGenres);
            selectedTags = parseInitialItems(@Html.Raw(Json.Serialize(Model.Tags)));
            console.log("DOMContentLoaded: selectedTags after parsing Model.Tags:", selectedTags);

            if (hiddenGenresInput) hiddenGenresInput.value = JSON.stringify(selectedGenres);
            if (hiddenTagsInput) hiddenTagsInput.value = JSON.stringify(selectedTags);

            function renderSelectedItemsAsBadges(containerId, selectedArray, hiddenInputElement, type, allItemsListRef, globalSelectedArrayRef) {
                console.log(`renderSelectedItemsAsBadges: Entering for containerId: ${containerId}, type: ${type}`, "selectedArray:", selectedArray);
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error(`renderSelectedItemsAsBadges: Container with ID ${containerId} not found.`);
                    return;
                }
                container.innerHTML = '';
                selectedArray.forEach(item => {
                    const badge = document.createElement('span');
                    badge.className = 'badge bg-secondary me-1 mb-1';
                    badge.textContent = item;
                    const removeBtn = document.createElement('span');
                    removeBtn.innerHTML = '&times;';
                    removeBtn.className = 'ms-1 fw-bold';
                    removeBtn.style.cursor = 'pointer';
                    removeBtn.onclick = function () {
                        console.log(`renderSelectedItemsAsBadges: Removing item: ${item} from type: ${type}`);
                        const index = globalSelectedArrayRef.indexOf(item);
                        if (index > -1) {
                            globalSelectedArrayRef.splice(index, 1);
                        }
                        if (hiddenInputElement) hiddenInputElement.value = JSON.stringify(globalSelectedArrayRef);
                        console.log(`renderSelectedItemsAsBadges: Updated globalSelectedArrayRef for ${type}:`, globalSelectedArrayRef);
                        renderSelectedItemsAsBadges(containerId, globalSelectedArrayRef, hiddenInputElement, type, allItemsListRef, globalSelectedArrayRef);
                    };
                    badge.appendChild(removeBtn);
                    container.appendChild(badge);
                });
                console.log(`renderSelectedItemsAsBadges: Exiting for containerId: ${containerId}`);
            }

            function populateModalWithCheckboxes(containerId, items, selectedItemsArray, type) {
                console.log(`populateModalWithCheckboxes: Entering for containerId: ${containerId}, type: ${type}`, "items:", items, "selectedItemsArray:", selectedItemsArray);
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error(`populateModalWithCheckboxes: Container with ID ${containerId} not found.`);
                    return;
                }
                container.innerHTML = '';
                items.forEach(item => {
                    const checkboxId = `${type}-${item.replace(/\s+/g, '-')}`;
                    const isChecked = selectedItemsArray.includes(item);
                    container.innerHTML += `
                            <div>
                                <input type="checkbox" id="${checkboxId}" name="${type}" value="${item}" ${isChecked ? 'checked' : ''}>
                                <label for="${checkboxId}">${item}</label>
                            </div>`;
                });
                console.log(`populateModalWithCheckboxes: Exiting for containerId: ${containerId}`);
            }

            const genreModal = document.getElementById('genreModal');
            const addGenreBtn = document.getElementById('addGenreBtn');
            const closeGenreModal = document.getElementById('closeGenreModal');
            if (addGenreBtn) addGenreBtn.onclick = function () {
                console.log("addGenreBtn.onclick: Opening genre modal. Initializing with allGenres:", allGenres, "selectedGenres:", selectedGenres);
                populateModalWithCheckboxes('genreListContainer', allGenres, selectedGenres, 'genre');
                if (genreModal) genreModal.style.display = 'block';
            }
            if (closeGenreModal) closeGenreModal.onclick = function () { if (genreModal) genreModal.style.display = 'none'; }

            const tagModal = document.getElementById('tagModal');
            const addTagBtn = document.getElementById('addTagBtn');
            const closeTagModal = document.getElementById('closeTagModal');
            if (addTagBtn) addTagBtn.onclick = function () {
                console.log("addTagBtn.onclick: Opening tag modal. Initializing with allTags:", allTags, "selectedTags:", selectedTags);
                populateModalWithCheckboxes('tagListContainer', allTags, selectedTags, 'tag');
                if (tagModal) tagModal.style.display = 'block';
            }
            if (closeTagModal) closeTagModal.onclick = function () { if (tagModal) tagModal.style.display = 'none'; }

            const saveGenreSelectionBtn = document.getElementById('saveGenreSelectionBtn');
            if (saveGenreSelectionBtn) saveGenreSelectionBtn.onclick = function () {
                console.log("saveGenreSelectionBtn.onclick: Saving genre selection.");
                selectedGenres = [];
                document.querySelectorAll('#genreListContainer input[type="checkbox"]:checked').forEach(cb => {
                    selectedGenres.push(cb.value);
                });
                console.log("saveGenreSelectionBtn.onclick: Selected genres:", selectedGenres);
                if (hiddenGenresInput) {
                    hiddenGenresInput.value = JSON.stringify(selectedGenres);
                    console.log("saveGenreSelectionBtn.onclick: Updated hiddenGenresInput value:", hiddenGenresInput.value);
                }
                if (genreModal) genreModal.style.display = 'none';
                renderSelectedItemsAsBadges('selectedGenresContainer', selectedGenres, hiddenGenresInput, 'genre', allGenres, selectedGenres);
            }

            const saveTagSelectionBtn = document.getElementById('saveTagSelectionBtn');
            if (saveTagSelectionBtn) saveTagSelectionBtn.onclick = function () {
                console.log("saveTagSelectionBtn.onclick: Saving tag selection.");
                selectedTags = [];
                document.querySelectorAll('#tagListContainer input[type="checkbox"]:checked').forEach(cb => {
                    selectedTags.push(cb.value);
                });
                console.log("saveTagSelectionBtn.onclick: Selected tags:", selectedTags);
                if (hiddenTagsInput) {
                    hiddenTagsInput.value = JSON.stringify(selectedTags);
                    console.log("saveTagSelectionBtn.onclick: Updated hiddenTagsInput value:", hiddenTagsInput.value);
                }
                if (tagModal) tagModal.style.display = 'none';
                renderSelectedItemsAsBadges('selectedTagsContainer', selectedTags, hiddenTagsInput, 'tag', allTags, selectedTags);
            }

            const addCustomGenreBtn = document.getElementById('addCustomGenreBtn');
            const customGenreInput = document.getElementById('customGenreInput');
            if (addCustomGenreBtn && customGenreInput) addCustomGenreBtn.onclick = function () {
                const newGenre = customGenreInput.value.trim();
                console.log("addCustomGenreBtn.onclick: Adding custom genre:", newGenre);
                if (newGenre && !allGenres.includes(newGenre)) {
                    allGenres.push(newGenre);
                    console.log("addCustomGenreBtn.onclick: Updated allGenres:", allGenres);
                }
                if (newGenre && !selectedGenres.includes(newGenre)) {
                    selectedGenres.push(newGenre);
                    console.log("addCustomGenreBtn.onclick: Updated selectedGenres:", selectedGenres);
                }
                populateModalWithCheckboxes('genreListContainer', allGenres, selectedGenres, 'genre');
                if (customGenreInput) customGenreInput.value = '';
            };

            const addCustomTagBtn = document.getElementById('addCustomTagBtn');
            const customTagInput = document.getElementById('customTagInput');
            if (addCustomTagBtn && customTagInput) addCustomTagBtn.onclick = function () {
                const newTag = customTagInput.value.trim();
                console.log("addCustomTagBtn.onclick: Adding custom tag:", newTag);
                if (newTag && !allTags.includes(newTag)) {
                    allTags.push(newTag);
                    console.log("addCustomTagBtn.onclick: Updated allTags:", allTags);
                }
                if (newTag && !selectedTags.includes(newTag)) {
                    selectedTags.push(newTag);
                    console.log("addCustomTagBtn.onclick: Updated selectedTags:", selectedTags);
                }
                populateModalWithCheckboxes('tagListContainer', allTags, selectedTags, 'tag');
                if (customTagInput) customTagInput.value = '';
            };

            window.onclick = function (event) {
                if (event.target == genreModal) {
                    if (genreModal) genreModal.style.display = 'none';
                }
                if (event.target == tagModal) {
                    if (tagModal) tagModal.style.display = 'none';
                }
            };

            renderSelectedItemsAsBadges('selectedGenresContainer', selectedGenres, hiddenGenresInput, 'genre', allGenres, selectedGenres);
            renderSelectedItemsAsBadges('selectedTagsContainer', selectedTags, hiddenTagsInput, 'tag', allTags, selectedTags);

            // --- Author Autocomplete ---
            const authorNameInput = document.getElementById('authorNameInput');
            const authorIdInput = document.getElementById('AuthorId');
            const suggestions = document.getElementById('authorSuggestionsContainer');
            authorNameInput.addEventListener('input', function () {
                const query = this.value.trim();
                console.log("authorNameInput event listener: Query:", query);
                authorIdInput.value = ''; // Clear previous selection
                if (query.length < 2) {
                    suggestions.style.display = 'none';
                    suggestions.innerHTML = '';
                    return;
                }
                fetch('/api/Users/search?nameQuery=' + encodeURIComponent(query) + '&limit=4')
                    .then(res => res.ok ? res.json() : Promise.resolve([])) // Resolve with empty array on error to simplify
                    .then(users => {
                        console.log("authorNameInput event listener: Received users from API:", users);
                        suggestions.innerHTML = '';
                        if (users && users.length > 0) {
                            users.forEach(u => {
                                const div = document.createElement('div');
                                div.className = 'author-suggestion-item';
                                div.innerHTML = `<img src="${u.avatarUrl || '/Resource/default-avatar.jpg'}" class="author-suggestion-avatar" alt="">
                                        <span>${u.login}</span>`;
                                div.addEventListener('mousedown', function (evt) {
                                    evt.preventDefault();
                                    console.log("authorNameInput event listener: Selected user:", u);
                                    authorNameInput.value = u.login;
                                    authorIdInput.value = u.id;
                                    suggestions.style.display = 'none';
                                });
                                suggestions.appendChild(div);
                            });
                            suggestions.style.display = 'block';
                        } else {
                            suggestions.style.display = 'none';
                        }
                    })
                    .catch(error => {
                        console.error("authorNameInput event listener: Error fetching users:", error);
                        suggestions.style.display = 'none';
                        suggestions.innerHTML = '';
                    });
            });
            document.addEventListener('mousedown', function (e) {
                if (!suggestions.contains(e.target) && e.target !== authorNameInput) {
                    suggestions.style.display = 'none';
                }
            });
            authorNameInput.addEventListener('keydown', function (e) {
                if ((e.key === 'Enter' || e.key === 'Tab') && suggestions.style.display === 'block') {
                    const firstItem = suggestions.querySelector('.author-suggestion-item');
                    if (firstItem) {
                        e.preventDefault();
                        firstItem.dispatchEvent(new MouseEvent('mousedown'));
                    }
                }
            });

            // --- Related Novels ---
            const relatedNovelSearchInput = document.getElementById('relatedNovelSearchInput');
            const relatedNovelSuggestionsContainer = document.getElementById('relatedNovelSuggestionsContainer');
            const selectedRelatedNovelsContainer = document.getElementById('selectedRelatedNovelsContainer');
            const hiddenRelatedNovelIdsInput = document.getElementById('RelatedNovelIds');
            let selectedNovelsData = [];
            const initialRelatedNovelIdsString = @Html.Raw(Json.Serialize(Model.RelatedNovelIds));
            console.log("DOMContentLoaded: initialRelatedNovelIdsString from Model:", initialRelatedNovelIdsString);

            function fetchAndRenderInitialRelatedNovels() {
                console.log("fetchAndRenderInitialRelatedNovels: Entering with initialRelatedNovelIdsString:", initialRelatedNovelIdsString);
                if (initialRelatedNovelIdsString && hiddenRelatedNovelIdsInput) {
                    let initialIds = [];
                    try {
                        const parsedJson = JSON.parse(initialRelatedNovelIdsString);
                        if (Array.isArray(parsedJson)) {
                            initialIds = parsedJson.map(id => parseInt(id, 10)).filter(id => !isNaN(id) && id > 0);
                        } else {
                            console.warn("fetchAndRenderInitialRelatedNovels: Parsed RelatedNovelIds is not an array, falling back to comma-separated parsing.");
                            initialIds = initialRelatedNovelIdsString.split(',')
                                .map(idStr => parseInt(idStr.trim(), 10))
                                .filter(id => !isNaN(id) && id > 0);
                        }
                    } catch (e) {
                        console.warn("fetchAndRenderInitialRelatedNovels: JSON parsing of RelatedNovelIds failed, falling back to comma-separated parsing. Error:", e);
                        initialIds = initialRelatedNovelIdsString.split(',')
                            .map(idStr => parseInt(idStr.trim(), 10))
                            .filter(id => !isNaN(id) && id > 0);
                    }
                    console.log("fetchAndRenderInitialRelatedNovels: Parsed initialIds:", initialIds);

                    if (initialIds.length > 0) {
                        selectedNovelsData = initialIds.map(id => ({ id: id, title: "ID: " + id + " (загрузка...)" }));
                        renderSelectedNovelsBadges();
                        updateHiddenRelatedNovelIdsInput(); // Log inside this function

                        fetch(`/api/Novels/detailsByIds?ids=${initialIds.join(',')}`)
                            .then(response => {
                                if (!response.ok) {
                                    console.error("fetchAndRenderInitialRelatedNovels: Error fetching novel details, status:", response.status);
                                    throw new Error(`HTTP error! status: ${response.status}`);
                                }
                                return response.json();
                            })
                            .then(novelsFromServer => {
                                console.log("fetchAndRenderInitialRelatedNovels: Received novelsFromServer:", novelsFromServer);
                                if (novelsFromServer && Array.isArray(novelsFromServer)) {
                                    selectedNovelsData = selectedNovelsData.map(selNovel => {
                                        const foundNovel = novelsFromServer.find(srvNovel => srvNovel.id === selNovel.id);
                                        return foundNovel ? { id: foundNovel.id, title: foundNovel.title, coverUrl: foundNovel.firstCoverUrl } : selNovel;
                                    });
                                    renderSelectedNovelsBadges(); // Log inside this function
                                }
                            })
                            .catch(error => {
                                console.error("fetchAndRenderInitialRelatedNovels: Error fetching initial related novel details:", error);
                                selectedNovelsData = selectedNovelsData.map(novel => ({ ...novel, title: `ID: ${novel.id} (ошибка)` }));
                                renderSelectedNovelsBadges(); // Log inside this function
                            });
                    }
                }
                console.log("fetchAndRenderInitialRelatedNovels: Exiting.");
            }
            function createNovelBadge(novel) {
                console.log("createNovelBadge: Creating badge for novel:", novel);
                const badge = document.createElement('span');
                badge.className = 'badge bg-info me-2 mb-2 d-flex align-items-center p-1';
                let badgeContent = '';
                badgeContent += novel.title;
                badge.innerHTML = badgeContent;
                const removeBtn = document.createElement('span');
                removeBtn.innerHTML = '&times;';
                removeBtn.className = 'ms-2 fw-bold remove-related-novel-btn';
                removeBtn.style.cursor = 'pointer';
                removeBtn.style.marginLeft = 'auto';
                removeBtn.onclick = function () {
                    console.log("createNovelBadge removeBtn.onclick: Removing novel:", novel, "Current selectedNovelsData:", selectedNovelsData);
                    selectedNovelsData = selectedNovelsData.filter(n => n.id !== novel.id);
                    console.log("createNovelBadge removeBtn.onclick: Updated selectedNovelsData:", selectedNovelsData);
                    renderSelectedNovelsBadges();
                    updateHiddenRelatedNovelIdsInput();
                };
                badge.appendChild(removeBtn);
                return badge;
            }
            function renderSelectedNovelsBadges() {
                console.log("renderSelectedNovelsBadges: Rendering badges for selectedNovelsData:", selectedNovelsData);
                if (!selectedRelatedNovelsContainer) {
                    console.error("renderSelectedNovelsBadges: selectedRelatedNovelsContainer not found.");
                    return;
                }
                selectedRelatedNovelsContainer.innerHTML = '';
                selectedNovelsData.forEach(novel => {
                    const badge = createNovelBadge(novel); // Log inside createNovelBadge
                    selectedRelatedNovelsContainer.appendChild(badge);
                });
            }
            function updateHiddenRelatedNovelIdsInput() {
                if (hiddenRelatedNovelIdsInput) {
                    const newValue = selectedNovelsData.map(n => n.id).join(',');
                    hiddenRelatedNovelIdsInput.value = newValue;
                    console.log("updateHiddenRelatedNovelIdsInput: Updated hiddenRelatedNovelIdsInput value to:", newValue);
                } else {
                    console.error("updateHiddenRelatedNovelIdsInput: hiddenRelatedNovelIdsInput not found.");
                }
            }
            fetchAndRenderInitialRelatedNovels(); // Logs inside the function

            // --- Cover Image Management & Form Submission ---
            const form = document.getElementById('novelEditForm');
            const newCoverFilesInput = document.getElementById('NewCovers');
            let newSelectedFiles = []; // To keep track of files selected in the NewCoverFiles input

            // Preview logic for NewCovers (largely kept for UI, but won't be submitted with JSON)
            const newCoversPreviewContainer = document.createElement('div');
            newCoversPreviewContainer.id = 'newCoversPreviewContainer';
            newCoversPreviewContainer.className = 'mt-2 d-flex flex-wrap';
            if (newCoverFilesInput) {
                const fileInputFormGroup = newCoverFilesInput.closest('.form-group');
                if (fileInputFormGroup && fileInputFormGroup.parentNode) {
                    fileInputFormGroup.parentNode.insertBefore(newCoversPreviewContainer, fileInputFormGroup.nextSibling);
                }
            }
            // The JavaScript form submission logic has been removed to allow standard MVC form submission.
            // Cover management (delete existing, preview new) and other UI logic remains.
            // The form will now submit via HTTP POST to the asp-controller and asp-action.
            // File uploads (NewCovers) will be handled by the standard MVC model binding.
            // Kept existing covers are submitted via their hidden input fields.

            // Keep the existing preview and removal logic for NewCoverFiles for UI consistency,
            // even if files are not submitted via this specific JSON PUT.
            // The user will be alerted about the new file upload process.
            if (newCoverFilesInput) {
                newCoverFilesInput.addEventListener('change', function (event) {
                    console.log("NewCovers change event: Files selected.");
                    newCoversPreviewContainer.innerHTML = '';
                    newSelectedFiles = []; // Reset newSelectedFiles array
                    const files = event.target.files;
                    console.log("NewCovers change event: Number of files selected:", files.length, "Files:", Array.from(files).map(f => f.name));


                    if (files && files.length > 0) {
                        const titleLabel = document.createElement('p');
                        titleLabel.textContent = 'Preview of new covers:';
                        titleLabel.className = 'w-100 mb-1';
                        newCoversPreviewContainer.appendChild(titleLabel);
                    }

                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        if (file.type.startsWith('image/')) {
                            newSelectedFiles.push(file); // Add to our tracking array
                            const reader = new FileReader();
                            reader.onload = function (e) {
                                const previewItem = document.createElement('div');
                                previewItem.className = 'current-cover-item me-2 mb-2';
                                previewItem.style.position = 'relative';
                                previewItem.style.border = '1px solid #007bff'; // Indicate it's a new preview
                                previewItem.style.padding = '5px';
                                previewItem.style.width = '112px';
                                previewItem.style.height = '162px';

                                const img = document.createElement('img');
                                img.src = e.target.result;
                                img.alt = 'Preview of new cover';
                                img.style.width = '100px';
                                img.style.height = '150px';
                                img.style.display = 'block';
                                img.style.objectFit = 'cover';

                                const removeBtn = document.createElement('button');
                                removeBtn.innerHTML = '&times;';
                                removeBtn.type = 'button'; // Important for forms
                                removeBtn.className = 'btn btn-danger btn-sm';
                                removeBtn.style.position = 'absolute';
                                removeBtn.style.top = '0px';
                                removeBtn.style.right = '0px';
                                removeBtn.style.padding = '1px 4px';
                                removeBtn.style.lineHeight = '1';
                                removeBtn.onclick = function () {
                                    console.log("NewCovers preview removeBtn.onclick: Removing preview for file:", file.name);
                                    previewItem.remove();
                                    // Remove from newSelectedFiles array
                                    newSelectedFiles = newSelectedFiles.filter(f => f !== file);
                                    // Update the input's files collection
                                    const dataTransfer = new DataTransfer();
                                    newSelectedFiles.forEach(f => dataTransfer.items.add(f));
                                    event.target.files = dataTransfer.files; // This effectively updates the FileList
                                    console.log("NewCovers preview removeBtn.onclick: Updated newSelectedFiles:", newSelectedFiles.map(f=>f.name), "Input files count:", event.target.files.length);
                                    if (newCoversPreviewContainer.querySelectorAll('.current-cover-item').length === 0) {
                                        const existingTitle = newCoversPreviewContainer.querySelector('p');
                                        if (existingTitle) existingTitle.remove();
                                    }
                                };
                                previewItem.appendChild(img);
                                previewItem.appendChild(removeBtn);
                                newCoversPreviewContainer.appendChild(previewItem);
                            }
                            reader.readAsDataURL(file);
                        }
                    }
                    // Don't reset event.target.value to null here if you want to keep the FileList for form submission
                });
            } else {
                console.error("NewCovers input with ID 'NewCovers' not found. Change event listener NOT attached.");
            }

            const currentCoversContainer = document.getElementById('currentCoversContainer');
            if (currentCoversContainer) {
                currentCoversContainer.addEventListener('click', function (event) {
                    if (event.target.classList.contains('remove-cover-btn')) {
                        const coverPath = event.target.dataset.coverPath;
                        console.log("currentCoversContainer click: Remove button clicked for existing cover path:", coverPath);
                        const coverItemDiv = event.target.closest('.current-cover-item');
                        if (coverItemDiv) {
                            const hiddenInput = coverItemDiv.querySelector('.kept-cover-input');
                            if (hiddenInput) {
                                hiddenInput.remove(); // Remove the hidden input that keeps this cover
                                console.log("currentCoversContainer click: Removed hidden input for cover:", coverPath);
                            }
                            // Create a hidden input to mark this cover for deletion
                            const deletionInput = document.createElement('input');
                            deletionInput.type = 'hidden';
                            deletionInput.name = 'CoversToDelete'; // Ensure your model binder can pick this up
                            deletionInput.value = coverPath;
                            form.appendChild(deletionInput); // Add to form to be submitted
                            console.log("currentCoversContainer click: Added hidden input to delete cover:", coverPath);

                            coverItemDiv.remove(); // Remove the visual representation
                            if (!currentCoversContainer.querySelector('.current-cover-item')) {
                                const noCoversMsg = document.createElement('p');
                                noCoversMsg.textContent = 'All covers removed.';
                                currentCoversContainer.appendChild(noCoversMsg);
                            }
                        }
                    }
                });
            } else {
                console.error("currentCoversContainer not found.");
            }

            // --- Debounce for Related Novels ---
            function debounce(func, delay) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), delay);
                };
            }
            const debouncedFetchRelatedNovels = debounce(function (query) {
                console.log("debouncedFetchRelatedNovels: Query:", query);
                if (!relatedNovelSuggestionsContainer) return;
                if (query.length < 2) {
                    relatedNovelSuggestionsContainer.style.display = 'none';
                    relatedNovelSuggestionsContainer.innerHTML = '';
                    return;
                }
                fetch('/api/Novels/search?query=' + encodeURIComponent(query) + '&limit=5')
                    .then(response => response.ok ? response.json() : Promise.reject('Failed to fetch'))
                    .then(novels => {
                        console.log("debouncedFetchRelatedNovels: Received novels from API:", novels);
                        relatedNovelSuggestionsContainer.innerHTML = '';
                        if (novels && novels.length > 0) {
                            novels.forEach(novel => {
                                if (selectedNovelsData.some(selected => selected.id === novel.id)) {
                                    return; // Skip if already selected
                                }
                                const suggestionDiv = document.createElement('div');
                                suggestionDiv.className = 'author-suggestion-item';
                                suggestionDiv.style.cursor = 'pointer';
                                const imageUrl = novel.firstCoverUrl ? novel.firstCoverUrl : '/Resource/default.jpg';
                                suggestionDiv.innerHTML = `
                                        <img src="${imageUrl}" class="author-suggestion-avatar related-novel-suggestion-cover" alt="Cover">
                                        <span>${novel.title} (ID: ${novel.id})</span>`;
                                suggestionDiv.addEventListener('click', function () {
                                    console.log("debouncedFetchRelatedNovels suggestionDiv.click: Adding novel:", novel, "Current selectedNovelsData:", selectedNovelsData);
                                    if (!selectedNovelsData.some(selected => selected.id === novel.id)) {
                                        selectedNovelsData.push({ id: novel.id, title: novel.title, coverUrl: novel.firstCoverUrl });
                                        console.log("debouncedFetchRelatedNovels suggestionDiv.click: Updated selectedNovelsData:", selectedNovelsData);
                                        renderSelectedNovelsBadges();
                                        updateHiddenRelatedNovelIdsInput();
                                    }
                                    if (relatedNovelSearchInput) relatedNovelSearchInput.value = '';
                                    relatedNovelSuggestionsContainer.style.display = 'none';
                                    relatedNovelSuggestionsContainer.innerHTML = '';
                                });
                                relatedNovelSuggestionsContainer.appendChild(suggestionDiv);
                            });
                            relatedNovelSuggestionsContainer.style.display = 'block';
                        } else {
                            relatedNovelSuggestionsContainer.style.display = 'none';
                        }
                    })
                    .catch(error => {
                        console.error("debouncedFetchRelatedNovels: Error fetching related novels:", error);
                        if (relatedNovelSuggestionsContainer) relatedNovelSuggestionsContainer.style.display = 'none';
                    });
            }, 300);
            if (relatedNovelSearchInput) {
                relatedNovelSearchInput.addEventListener('input', function () {
                    debouncedFetchRelatedNovels(this.value.trim());
                });
                document.addEventListener('click', function (e) {
                    if (relatedNovelSuggestionsContainer && !relatedNovelSuggestionsContainer.contains(e.target) && e.target !== relatedNovelSearchInput) {
                        relatedNovelSuggestionsContainer.style.display = 'none';
                    }
                });
                relatedNovelSearchInput.addEventListener('keydown', function (e) {
                    if ((e.key === 'Enter' || e.key === 'Tab') && relatedNovelSuggestionsContainer && relatedNovelSuggestionsContainer.style.display === 'block') {
                        const firstItem = relatedNovelSuggestionsContainer.querySelector('.author-suggestion-item');
                        if (firstItem) {
                            e.preventDefault();
                            firstItem.dispatchEvent(new MouseEvent('click')); // Will trigger logs in its own handler
                        }
                    }
                });
            }
            console.log("DOMContentLoaded: End");
        });
    </script>
</body>
</html>